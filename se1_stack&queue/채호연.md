## 1. [다리를 지나는 트럭](https://school.programmers.co.kr/learn/courses/30/lessons/42583)

### 문제 설명
트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다.
다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다. 단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.

예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.

### 풀이
```java
import java.util.ArrayDeque;

class Solution {
    class Truck {
        int entranceTime;
        int weight;
        
        public Truck(int t, int w){this.entranceTime = t; this.weight = w;}
    }
    
    public int solution(int bridge_length, int weight, int[] truck_weights) {
        
        // 0. Initialization
        ArrayDeque<Truck> bridge = new ArrayDeque<>();
        int time = 0;
        int weightSumOnBridge = 0;
        int nextTruckIdx = 0;
        
        // 1. Putting first car on bridge. (at 1 second)
        time++;
        bridge.addFirst(new Truck(time, truck_weights[nextTruckIdx]));
        weightSumOnBridge += truck_weights[nextTruckIdx];
        nextTruckIdx++;
        
        // 2. From 2 seconds...
        while(!bridge.isEmpty()){
            time++; // 1초 경과
            
            // 1) 출차 필요 차량 있는지 확인 후, 있다면 출차 처리
            if(time - bridge.peekLast().entranceTime == bridge_length){
                weightSumOnBridge -= bridge.peekLast().weight;
                bridge.pollLast(); // 출차
            }
            
            // 2) 새로운 차량 입차 가능 여부 확인 후 가능하다면 입차 처리
            if(nextTruckIdx < truck_weights.length
              && weightSumOnBridge + truck_weights[nextTruckIdx] <= weight){
                bridge.addFirst(new Truck(time, truck_weights[nextTruckIdx]));
                weightSumOnBridge += truck_weights[nextTruckIdx];
                nextTruckIdx++;
            }
        }
        
        return time;
    }
}
```

## 2. [괄호](https://www.acmicpc.net/problem/9012)
### 문제 설명
괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다.
그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다. 

여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다. 

### 풀이
```java
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.util.ArrayDeque;

/*
 1. 입력 문자열을 받는다.
 2. 문자열을 구성하는 문자 각각에 대해 다음과 같은 작업을 수행한다.
   i) 문자 == '(' : 스택에 삽입
   ii) 문자 == ')' : 스택에 가장 마지막으로 삽입된 좌괄호 pop.
 3. 전체 문자열 탐색 후, Stack 이 비어있다면 VPS이다.
 
 <왜 Stack 인가?>
 - 어떤 좌괄호와 우괄호가 서로 짝을 짓고 있는지 알아야한다.
 - 괄호의 특성 상, 가장 먼저 등장한 우괄호와 짝을 이루는 좌괄호는 가장 마지막에 등장한 괄호이다.
 - 이러한 점에 주목했을 때, '좌괄호를 출현한 순서대로 넣고, 그와 반대로 뽑아서 비교하기'가 가능하도록 돕는 자료구조가 필요하다. 
 - 즉, 후입선출 자료구조를 활용하여 해결할 수 있다.

 */


public class Main {
    public static void main(String[] args) throws IOException {
        
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int TC = Integer.parseInt(br.readLine());
        StringBuilder answer = new StringBuilder();
        
        for(int tc = 0; tc < TC; tc++){
            String result = isVPS(br.readLine());
            answer.append(result);
            if(tc < TC - 1){answer.append("\n");}
        }
        
        System.out.print(answer.toString());
    }
    
    private static String isVPS(String s){
        ArrayDeque<Character> stack = new ArrayDeque<>();
        ArrayDeque<Character> rightParenthesisStack = new ArrayDeque<>();
        
        for(int idx = 0; idx < s.length(); idx++){
            char current = s.charAt(idx);
            
            if(current == '('){stack.push(current);}
            else if(current == ')'){
                if(!stack.isEmpty()){stack.pop();}
                else{rightParenthesisStack.push(current);}
            }
        }
        
        return (stack.isEmpty() && rightParenthesisStack.isEmpty()) ? ("YES") : ("NO");
    }
}
```
