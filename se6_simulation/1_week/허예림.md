https://www.acmicpc.net/problem/21611

### 문제 해설

- N*N크기의 격자 가운데 상어가 자리하고 있음
- 그외 칸에는 1, 2, 3 구슬이 놓여있거나 비어있음
- 상어가 총 M번의 마법을 사용할 수 있고, d방향으로 s칸만큼 구슬 파괴
    - d 방향 (1(상), 2(하), 3(좌), 4(우))
    - s 거리  : 상어로부터 s칸까지 영향
- 구슬이 파괴 된 후 구슬이 앞으로 이동하여 빈칸을 채움
- 회오리 모양 (가운데부터 왼쪽 → 아래 → 오른쪽 → 위쪽)으로 채워짐
- 채워진 후 같은 구슬이 4개 이상 연속되어 있으면 폭발
- 점수 : 번호 * 폭발한 개수
- 더이상 폭발할 구슬이 없으면 구슬의 형태를 변화시킴
    - 구슬이 몇개 있었는지 a ,구슬의 번호 b → [a, b, a,b]
- 턴이 모두 끝나고난후 몇번 구슬이 몇개 폭파되었는 지 출력

**풀이 방법**

- 회오리 순서를 일렬 배열로 구성후 다시 배열 형태로되돌림
- 한턴을 처리하는 로직을 분리하여 m번 반복
- 상어 죄표를 기준으로 좌 → 하 → 우 → 상 112233 만큼 이동하는 회오리 순서를 사용
- 현재 보드를 회오리 순서로 1차원 배열로 반환
    - 배열에 같은 숫자가 4개이상 존재하면 0으로 변환 후 폭발한 구슬의 개수를 숫자 별로 result에 저장
    - 폭발이 존재하지 않을 때 까지 반복
- 1차원 배열을 다시 회오리 순서로 보드에 저장
- 모든 턴이 끝나면 result에 누적된 폭팔 개수로 출력

```python
import sys

input = sys.stdin.readline

n, m = map(int, input().split())
board = [list(map(int, input().split())) for _ in range(n)]
spells = [tuple(map(int, input().split())) for _ in range(m)]

cx = cy = (n - 1) // 2
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

result = [0, 0, 0]

path = []
def make_spiral():
    dx = [0, 1, 0, -1]
    dy = [-1, 0, 1, 0]
    step = 1
    x, y = cx, cy
    while True:
        for dir_idx in range(4):
            for _ in range(step):
                x += dx[dir_idx]
                y += dy[dir_idx]
                if x < 0 or y < 0 or x >= n or y >= n:
                    return
                path.append((x, y))
            if dir_idx % 2 == 1:
                step += 1

def cast(d, s):
    cast_dx, cast_dy = dx[d - 1], dy[d - 1]
    for dist in range(1, s + 1):
        nx = cx + cast_dx * dist
        ny = cy + cast_dy * dist
        if nx < 0 or ny < 0 or nx >= n or ny >= n:
            break
        board[nx][ny] = 0

def compress(arr):
    out = []
    for v in arr:
        if v:
            out.append(v)
    return out

def explode(arr):
    if not arr:
        return arr, False

    changed = False
    out = arr[:]
    i = 0
    while i < len(arr):
        j = i + 1
        while j < len(arr) and arr[j] == arr[i]:
            j += 1
        run_len = j - i
        if arr[i] != 0 and run_len >= 4:
            val = arr[i]
            for k in range(i, j):
                out[k] = 0
            if 1 <= val <= 3:
                result[val - 1] += run_len
            changed = True
        i = j

    if changed:
        out = compress(out)
    return out, changed

def to_list():
    arr = [0] * path_len
    for i, (x, y) in enumerate(path):
        arr[i] = board[x][y]
    return arr

def to_board(arr):
    if len(arr) > path_len:
        arr = arr[:path_len]
    fill_len = path_len - len(arr)
    if fill_len:
        arr = arr + [0] * fill_len
    for i, (x, y) in enumerate(path):
        board[x][y] = arr[i]

def groupify(arr):
    if not arr:
        return []

    grouped = []
    i = 0
    while i < len(arr):
        j = i + 1
        while j < len(arr) and arr[j] == arr[i]:
            j += 1
        run_len = j - i
        grouped.append(run_len)
        grouped.append(arr[i])
        i = j
        if len(grouped) >= path_len:
            break
    return grouped[:path_len]

make_spiral()
path_len = len(path)

for d, s in spells:
    cast(d, s)
    linear = to_list()
    linear = compress(linear)
    while True:
        linear, changed = explode(linear)
        if not changed:
            break
    grouped = groupify(linear)
    to_board(grouped)

print(result[0] + 2 * result[1] + 3 * result[2])

```
