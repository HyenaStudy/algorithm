## I. [트리의 지름](https://www.acmicpc.net/problem/1967)

### 1. 풀이 아이디어 및 정당성 증명
트리에서 서로 가장 멀리 떨어져있는 두 정점을 연결한 경로의 길이를 '트리의 지름'이라고 합니다.
이때, 트리의 지름은 2번의 BFS 또는 DFS 로 구할 수 있습니다!

아래 정당성 증명은 그냥 DFS로 예시를 들어진행하겠습니다.(아무 이유 없습니다!)

핵심은, 어떤 한 정점에서 가장 먼 정점 V을 고르고, 그 정점으로부터 다시 가장 먼 정점 W를 찾습니다.
이 두 정점 V, W가 바로 트리의 지름을 구성하는 양 끝 정점입니다.

### 정당성 증명
증명은 귀류법을 이용해 진행됩니다!

**증명의 핵심 가정 (결론의 부정)**

"알고리즘으로 찾은 경로 v-w가 실제 트리의 지름이 아니다"라고 가정해 보겠습니다.

이 가정이 참이라면, 트리에는 v-w 경로보다 더 긴 지름이 존재해야 합니다. 그 진짜 지름을 경로 a-b라고 하겠습니다.

**상황 분석**

우리가 가정한 두 경로, 즉 알고리즘으로 찾은 v-w와 실제 지름이라고 가정한 a-b는 트리 안에서 다음과 같은 관계를 가질 수 있습니다.

> * i) 두 경로가 서로 겹치지 않는 경우
>
> * ii) 두 경로가 일부를 공유하며 겹치는 경우

두 경우 모두에서 모순이 발생함을 보이면 증명이 됩니다!

**i) 두 경로가 서로 겹치지 않는 경우**

경로 v-w와 경로 a-b가 서로 만나지 않고 완전히 떨어져 있는 상황을 생각해 봅시다.

<img width="432" height="328" alt="Screenshot 2025-10-12 at 9 55 02 PM" src="https://github.com/user-attachments/assets/7e6afaa4-40f7-4c77-a8a6-260fc8282347" />


경로 a-b 위의 한 점 x와 경로 v-w 위의 한 점 y를 잇는 경로가 반드시 존재합니다. 이는 트리의 성질에 기인합니다.

첫 번째 DFS는 임의의 정점 u에서 시작하여 가장 먼 정점 v를 찾았습니다.

정의에 따라, dist(u, v) >= dist(u, a) 이고 dist(u, v) >= dist(u, b) 입니다.

이제 a와 b 중 u에서 더 먼 정점을 b라고 가정해 봅시다. (dist(u, b) >= dist(u, a))

경로 a-b와 v-u를 연결하면 a에서 v까지의 새로운 경로(a → x → y → v)를 만들 수 있습니다.

이때 경로 a-v의 길이는 dist(a,x) + dist(x,y) + dist(y,v) 입니다.

마찬가지로 경로 b-v의 길이도 생각할 수 있습니다.

여기서 핵심적인 모순이 발생합니다.

a에서 b까지의 경로와 u에서 v까지의 경로를 연결하는 점들을 고려했을 때, a에서 v까지의 거리 또는 b에서 v까지의 거리가 a에서 b까지의 거리보다 길어지게 됩니다. 이는 a-b가 가장 긴 경로(지름)라는 가정에 위배됩니다.

더 직관적으로 설명하자면, 서로 떨어져 있는 두 최장 경로가 있다면, 한 경로의 끝점에서 다른 경로의 끝점으로 가는 경로는 기존의 '최장 경로'보다 더 길어지므로 모순입니다.

2. 두 경로가 일부를 공유하며 겹치는 경우

<img width="396" height="324" alt="Screenshot 2025-10-12 at 9 57 35 PM" src="https://github.com/user-attachments/assets/1bfc91f6-7fa4-4e6c-8c6a-1e7bb031cb6f" />

이제 두 경로가 특정 구간(점 x와 y 사이)을 공유하는 경우를 생각해 봅시다.

가정: v-w는 알고리즘이 찾은 경로, a-b는 실제 지름입니다. 그리고 dist(a, b) > dist(v, w)라고 가정했습니다.

첫 번째 DFS: 임의의 정점 u에서 가장 먼 정점 v를 찾았습니다. 이는 u에서 가장 먼 정점이 v라는 의미이므로, dist(u, v) ≥ dist(u, a) 이고 dist(u, v) ≥ dist(u, b) 입니다.

두 번째 DFS: v에서 가장 먼 정점 w를 찾았습니다. 따라서 dist(v, w)는 v에서 출발하는 가장 긴 경로입니다.

이제 v에서 출발하는 경로들을 비교해 봅시다.

dist(v, w)는 v에서 가장 먼 정점까지의 거리입니다.

그런데, 우리가 a-b가 지름이라고 가정했으므로, dist(v, a) 또는 dist(v, b) 중 하나는 dist(v, w)보다 길어야 합니다.

경로를 dist(v, a) = dist(v, y) + dist(y, a) 로 분해할 수 있습니다.

또한 dist(a, b) = dist(a, y) + dist(y, b) 입니다.

여기서 v에서 가장 먼 점은 a, b, w 중 하나여야 합니다.

두 번째 DFS의 정의에 따라 dist(v, w) ≥ dist(v, a) 이고 dist(v, w) ≥ dist(v, b) 입니다.

이제 dist(a, b)를 v를 기준으로 생각해 보겠습니다.

경로 a-b는 v와 만나는 지점 y를 기준으로 a-y와 b-y로 나뉩니다.

dist(a, b) = dist(a, y) + dist(y, b) 입니다.

한편 v에서 가장 먼 점은 w이므로, dist(v, w) ≥ dist(v, b) 입니다.

만약 y가 v와 b 사이의 경로에 있다면, dist(v, b) = dist(v, y) + dist(y, b)가 됩니다.

따라서 dist(v, w) ≥ dist(v, y) + dist(y, b) 입니다.

우리의 초기 가정은 dist(a, b) > dist(v, w) 였습니다.

dist(a, y) + dist(y, b) > dist(v, w)

그런데 v에서 b까지의 거리는 dist(v,b)이고, v에서 가장 먼 점은 w이므로 dist(v,w) >= dist(v,b) 입니다.

a-b가 v-w보다 길다는 것은 a쪽 부분이 v쪽 부분보다 길다는 것을 의미하게 됩니다. (dist(a,y) > dist(v,y))

즉, dist(a, y) + dist(y, b) > dist(v, y) + dist(y, b) 가 되려면 dist(a, y) > dist(v, y) 여야 합니다.

이는 y를 기준으로 봤을 때 a가 v보다 더 멀리 있다는 뜻입니다.

하지만, v에서 가장 먼 점은 w입니다. 즉, dist(v,w) >= dist(v,a) 입니다.

dist(v,a) = dist(v,y) + dist(y,a)

따라서 dist(v,w) >= dist(v,y) + dist(y,a) 입니다.

여기서 모순이 발생합니다. 만약 a-b가 v-w보다 긴 지름이라면, v에서 가장 먼 노드는 w가 아니라 a 또는 b가 되어야 합니다. 이는 두 번째 DFS의 결과(v에서 가장 먼 노드는 w이다)와 정면으로 배치됩니다.

**결론**

어떤 경우를 가정하더라도(두 경로가 겹치든, 겹치지 않든), "알고리즘으로 찾은 경로 v-w가 진짜 지름이 아니다"라는 가정은 항상 모순을 만듭니다.

따라서 초기 가정은 거짓이며, "임의의 정점에서 가장 먼 정점을 찾고, 그 정점에서 다시 가장 먼 정점을 찾은 경로는 반드시 트리의 지름이다" 라는 원래의 명제는 참입니다.

### 2. 제출 코드
```java

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.BufferedReader;

import java.util.StringTokenizer;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class Main {
    static HashMap<Integer, ArrayList<Edge>> tree; // ArrayList<Edge> adjOfX = tree.get(x);
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        int N = Integer.parseInt(br.readLine()); // N : 정점 수
        tree = new HashMap<>();
        
        // 1. 트리 간선 정보 입력 받기. 정점 수가 1개인 경우 아래 입력은 수행되지 않는다.
        for(int n = 0; n < N - 1; n++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            Edge e = new Edge(x, y, w);
            Edge reverseE = new Edge(y, x, w);
            
            if(tree.containsKey(x)){
                tree.get(x).add(e);
            }
            else{
                ArrayList<Edge> adj = new ArrayList<>();
                adj.add(e);
                tree.put(x, adj);
            }
            
            if(tree.containsKey(y)){
                tree.get(y).add(reverseE);
            }
            else {
                ArrayList<Edge> adjRev = new ArrayList<>();
                adjRev.add(reverseE);
                tree.put(y, adjRev);
            }
        }
        
        // 2. 정점 수가 1개 이상인 경우 BFS 두 번 호출을 통해 지름을 구성하는 정점 및 거리 계산.
        //    정점 수가 1개인 경우 지름은 0이다.
        int diameter;
        
        if(N > 1){
            int[] a = BFS(1);
            int[] b = BFS(a[0]);
            diameter = b[1];
        }
        else {
            diameter = 0;
        }
        
        System.out.print(diameter);
        
    }
    
    public static int[] BFS(int source){
        int[] result = new int[2]; // result[0] : source 로 부터 가장 먼 거리의 정점 / result[1] : 거리
        result[1] = -Integer.MAX_VALUE;
        
        ArrayDeque<int[]> q = new ArrayDeque<>();
        HashSet<Integer> visited = new HashSet<>();
        q.addLast(new int[]{source, 0});
        visited.add(source);
        
        while(!q.isEmpty()){
            int[] current = q.removeFirst();
            int currentVertex = current[0];
            int distFromSource = current[1];
            
            ArrayList<Edge> adjEdges = tree.get(currentVertex);
            for(Edge edge : adjEdges){
                int adjVertex = edge.to;
                int weight = edge.weight;
                if(!visited.contains(adjVertex)){
                    int distByFarFromSource = distFromSource + weight;
                    if(distByFarFromSource > result[1]){
                        result[0] = adjVertex; result[1] = distByFarFromSource;
                    }
                    q.addLast(new int[]{adjVertex, distByFarFromSource});
                    visited.add(adjVertex);
                }
            }
        }
        
        return result;
    }
    
    
    static class Edge {
        int from;
        int to;
        int weight;
        
        public Edge(int x, int y, int w){
            this.from = x;
            this.to = y;
            this.weight = w;
        }
    }
}
```
