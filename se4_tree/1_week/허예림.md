https://www.acmicpc.net/problem/1967

**문제 내용**

- 트리의 지름을 구하는 문제
- 직선으로 연결 가능한 가장 먼 두 노드를 찾으면 됨
- 3개 이상부터는 직선으로 연결할 수 없음 (==지름이 아님)
- 가장 먼 a와 b를 구하면 그것도 지름이 되지만, 계속 초기화 하면서 드는 메모리 비용과, n 제곱이라는 시간 복잡도가 파이썬에서 수행 가능한 연산이 아님 ,  c++에선 될수도?

**해결 과정**

1. 현재 노드에서 가장 먼 노드A를 찾는다
2. 노드A에서 가장 먼 노드 B를 찾는다
3. 이 두 노드의 거리가 트리의 지름
4.  BFS는 큐를 이용해 각 노드까지의 누적 거리를 계산하며, 이미 방문한 노드는 다시 방문하지 않는다.

```python
from collections import deque

n = int(input().strip())
adj = [[] for _ in range(n + 1)]

# 간선 입력
for _ in range(n - 1):
    a, b, w = map(int, input().split())
    adj[a].append((b, w))
    adj[b].append((a, w))

start = 1
answer = 0

# 첫 번째 BFS: 1에서 가장 먼 노드 a
# 두 번째 BFS: a에서 가장 먼 노드까지의 거리 = 지름
for _ in range(2):
    # 초기 값을 -1로 지정하여 방문하지 않은 노드 판별
 
    dist = [-1] * (n + 1)
    # 1번 노드의 자기 자신까지의 거리 0을 의미
    dist[start] = 0
    # 1번 노드부터 순회
    q = deque([start])

    # 큐에 들어있는 노드 수 만큼 순회
		# bfs를 n번 반복하면 모든 노드를 빠짐없이 방문할 수 있음
		# 순회하면서 1번 노드부터 각 노드까지의 거리 계산
    for _ in range(n):
        if not q:
            break
        cur = q.popleft()
        for nxt, w in adj[cur]:
            if dist[nxt] == -1:
                dist[nxt] = dist[cur] + w
                q.append(nxt)

    # 가장 먼 노드 찾기
    far = 1
    for i in range(2, n + 1):
        if dist[i] > dist[far]:
            far = i

    # 두 번째 순회에서 dist 최대값이 지름
    answer = max(dist)
    start = far  # 다음 BFS의 시작 노드 갱신

print(answer)

```
