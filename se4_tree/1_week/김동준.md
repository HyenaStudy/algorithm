## 트리
### 문제 링크
https://www.acmicpc.net/problem/4803
### 정답 코드
```python
class Union_Find:
    def __init__(self, size):
        self.parent = list(range(size))
        self.rank = [0] * size

    def find_root(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find_root(self.parent[x])

        return self.parent[x]

    def union_root(self, x, y):
        root_x = self.find_root(x)
        root_y = self.find_root(y)

        # 합치기 전에 이미 같은 루트다 == 이미 같은 연결 성분이다
        if root_x == root_y:
            return

        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1

case = 1
answers = []

while True:
    N, M = map(int, input().split())

    if N == M == 0:
        break

    uf = Union_Find(N + 1)
    cycle = [False] * (N + 1) # 각 연결 요소마다 사이클 판별 확인

    for _ in range(M):
        # 간선이 제시된 순서대로 노드들을 연결해나가본다
        a, b = map(int, input().split())
        root_a = uf.find_root(a)
        root_b = uf.find_root(b)

        if root_a == root_b: # 이미 사이클이 형성된 상태
            cycle[root_a] = True
        else: # 아니라면 하나의 연결 성분으로 합침
            uf.union_root(root_a, root_b)
            new_root = uf.find_root(root_a)
            # 만약 두 연결 성분들 중 하나라도 사이클이 생기는 경우 반영
            cycle[new_root] = cycle[root_a] or cycle[root_b]

    roots = set()
    for i in range(1, N + 1):
        root = uf.find_root(i)

        # 사이클이 아니면서 루트의 지위를 유지하고 있는 애들만
        if not cycle[root]:
            roots.add(root)

    if len(roots) == 0:
        answers.append(f"Case {case}: No trees.")
    elif len(roots) == 1:
        answers.append(f"Case {case}: There is one tree.")
    else: # 2개 이상의 트리들로 구성된 집합 그래프
        answers.append(f"Case {case}: A forest of {len(roots)} trees.")

    case += 1

print(*answers, sep="\n")
```
### 풀이 아이디어
- 트리는 그래프의 일종으로, 레벨이 존재하며 사이클이 없는 그래프임
- 레벨은 트리의 루트 결정에 따라 매번 달라지므로 주어진 그래프(간선)에서 사이클이 존재하는지 판별하는 문제
- 입력 종류가 좀 까다롭게 주어지는 케이스가 많아서 서브그래프가 존재하면 서브그래프의 사이클들을 전부 하나씩 판별해야 함
- 사이클 판별은 간선이 무방향인 그래프여서 유니온 파인드 알고리즘으로 해결(유니온 전의 루트가 동일하면 사이클로 간주)

---

## 트리의 순회
### 문제 링크
https://www.acmicpc.net/problem/2263
### 정답 코드
```python
import sys
sys.setrecursionlimit(1_000_000)


class Node:
    def __init__(self, data):
        self.data = data
        self.left_child = None
        self.right_child = None


def recursion(in_start, in_end, post_start, post_end):
    if in_start > in_end or post_start > post_end:
        return None

    root_value = post_order[post_end]

    root = Node(root_value)
    root_in_index = in_order_index[root_value]

    root.left_child = recursion(
        in_start, root_in_index - 1, post_start, post_start + root_in_index - 1 - in_start
    ) # ok

    root.right_child = recursion(
        root_in_index + 1, in_end, post_start + root_in_index - in_start, post_end - 1
    )

    return root


def preorder_traversal(root, result):
    if root:
        result.append(root.data)
        preorder_traversal(root.left_child, result)
        preorder_traversal(root.right_child, result)


V = int(input())

in_order = list(map(int, input().split()))
post_order = list(map(int, input().split()))

in_order_index = {}

for i in range(len(in_order)):
    in_order_index[in_order[i]] = i

tree = recursion(0, len(in_order) - 1, 0, len(post_order) - 1)

result = []

preorder_traversal(tree, result)
print(' '.join(map(str, result)))
```
- 얘도 주석이 너무 지저분해서 일단 가독성을 위해 지웠습니다...
- 주석이 포함된 정답 코드는 [여기](https://github.com/kimD0ngjun/backjoon_programmers/blob/main/%EB%B0%B1%EC%A4%80/Gold/2263.%E2%80%85%ED%8A%B8%EB%A6%AC%EC%9D%98%E2%80%85%EC%88%9C%ED%9A%8C/%ED%8A%B8%EB%A6%AC%EC%9D%98%E2%80%85%EC%88%9C%ED%9A%8C.py)를 참고해주세요
### 풀이 아이디어
- 문제는 트리의 중위 순회와 후위 순회가 주어졌을 때 해당 트리의 전위 순회를 출력하는 것
- 순회가 가능한 이진 트리 자체가 재귀적으로 반복되는 구조를 활용해서 원본 트리를 완성한 다음에 전위 순회를 출력시키는 방향으로 해결
1. **후위 순회(왼 -> 오 -> 루)에 의해 서브트리 후위순회의 가장 마지막 요소가 해당 서브트리의 루트 노드**
2. **중위 순회와 후위 순회 둘 다 왼쪽 자식 서브트리부터 탐색 시작**
3. 서브트리의 루트 노드의 인덱스를 통해 **중위 순회에서 왼쪽 서브트리 인덱스 범위**를 계산하여, 그 간격이 후위 순회에서 왼쪽 자식 다음 **오른쪽 자식 서브트리의 시작 인덱스 파악**
4. 1번에서 찾은 루트 노드를 기준으로 2번과 3번 전반부까지를 통해 왼쪽 서브트리 인덱스 범위, 3번 후반부까지를 통해 오른쪽 서브트리 인덱스 범위를 계산해 재귀적으로 넘겨주면서 트리 완성
5. 트리 완성 후에는 전위 순회 함수 하나 만들어서 출력
