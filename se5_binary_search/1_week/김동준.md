# 입국 심사
### 문제 링크
https://www.acmicpc.net/problem/3079
### 정답 코드
```python
N, M = map(int, input().split())

# k번 심사대에서 걸리는 심사 시간: tables[k-1]
tables = [int(input()) for _ in range(N)]

# 독립적인 그리디 시뮬레이션
# 주어진 시간(time) 내로 M명의 인원을 커버할 수 있나?
def check(time) -> bool:
    """
    실제로는 병렬 처리겠지만, 지금은 가능성의 여부 판별이니까 순차적으로 단위 작업(사람) 배치해보며 가능한지 확인해보기

    time : 주어진 시간
    time // table : 한 심사대에서 '주어진 시간' 내에 처리 가능한 사람 수
    time % table : 최대한 처리했고 남은 쉬는 시간 -> 쥐어짜서 다른 사람도 받게 하려면 다음 심사대로 넘겨야 함
    그 다음으로 넘기는 나머지가 곧 time // next_table에 포함하게 됨(파이프 흐름 생각)
    """
    return M <= sum(time // table for table in tables)

min_time = 1
max_time = max(tables) * M
answer = max_time

while min_time <= max_time:
    mid = (max_time + min_time) // 2

    if check(mid):
        answer = mid
        max_time = mid - 1
    else:
        min_time = mid + 1

print(answer)
```
### 풀이 아이디어
- 이진탐색 문제는 배열 이진탐색과 범위 이진탐색(파라메트릭 서치)이 있는데, 개인적으로 범위 이진탐색 유형이 안 익숙한 편이라서 푼 문제
- 파라메트릭 서치는 상하한선 설정과 체크 분기 함수 작성이 오히려 메인인 것 같아요

---

# 가장 긴 증가하는 부분수열 문제 시리즈
### 문제 링크
https://www.acmicpc.net/problem/12015
### 정답 코드
```python
# https://www.acmicpc.net/problem/12015
import sys

input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

"""
기존 dp 기반 문제점 : O(N**2) = 전체 수열 탐색 N에 각 인덱스별 최대길이 갱신 작업 N
어떤 인덱스의 요소는 최대 길이를 계산에 고려할 필요조차 없는 값일 수도 있지만,
dp는 그걸 고려하지 않기 때문에 갱신 작업도 O(N) 
[10, 20, 30, 40, 0, 50, 60] 
-> 이런 경우에서 idx 4의 요소는 별 필요 없지만 얘를 거쳐야 dp 메모가 갱신 가능(불필요한 연산)

위의 케이스에서, idx 3은 길이 2, 3, 4 부분수열 최대값 -> 차후 50을 마주하면 또 갱신됨
"""
# memo[idx] : 길이가 idx + 1인 부분수열의 최대값
memo = []

for el in A:
    # 이진 탐색
    # memo에서 수열 요소 el이 들어갈 자리를 찾는다
    low = 0 # 분기당 memo 낮은 idx
    high = len(memo) - 1 # 분기당 memo 높은 idx

    while low <= high:
        # print(f"{temp_idx} 단계")
        mid = (low + high) // 2

        if memo[mid] < el:
            low = mid + 1
        else:
            high = mid - 1

    # memo 범위를 넘어서는 요소면 현재 memo 내의 값들보다 가장 큰 값
    if low >= len(memo):
        memo.append(el)
    # memo 범위 내라면 더 늘일 여지가 있는 해당 길이의 낮은 값(1, 2, 4 .... 3, 4 ...)
    else:
        memo[low] = el

print(len(memo))
```
### 풀이 아이디어
- 사실 이 문제는 오답코드입니다. `bisect` 모듈의 이진탐색 함수를 써야 간신히 통과하더라고요. 다른 언어는 커스텀 이진탐색을 써도 통과되던데... 걍 파이썬이 구데기...
- 예전에 DP 세션 때 풀었던 시리즈인데, DP의 갱신 단계에서의 O(N) 시간복잡도를 이진탐색으로 O(logN)으로 줄이는 게 목표 + 탐색된 mid 인덱스에 맞춰 memo에 갱신 혹은 추가 작업 수행
- memo의 인덱스가 곧 부분수열 길이를 맡기 때문에 누적식 연산(중간에 굳이 고려하지 않아도 되는 요소까지 고려하는)이 필요 없고, 길이 기준으로 최대값(마지막 값)을 갱신해나갈 수 있었네요
