# 백준 - 행렬 곱셈 순서

## 문제 유형
**구간 DP** - 구간 내 조건을 만족하는 최적해를 도출하기 위해, 이의 분할 구간 최적해를 활용하는 DP 유형.

지난 번의 '파일 합치기'와 결과적으로 동일한 문제에 해당하나, 한 두 가지 규칙이 암시로 제시되어 이를 정의하는 것이 필요하다는 점에서 별점 반의 반 개 정도 난이도를 더 줄 수 있는 문제입니다.

---

## I. 문제의 조건 분석 및 정리

문제를 다시 한 번 명확하게 정의해보겠습니다.

### 문제 요구 사항
"1개 이상 500개 이하의 행렬들이 주어질 때, 행렬을 모두 곱한 결과를 만들기 위해 필요한 곱셉 연산의 수 중 최소가 무엇인지 찾아라!"

### 행렬 곱셈 규칙
행렬 곱셈에 요구되는 곱셈 연산의 수는 다음과 같은 규칙에 의해 도출됩니다.

"행렬 A, B 가 각각 (N, M), (M, K) 구조를 갖는다고 하자. 이때 두 행렬 A, B 를 곱하기 위해 필요한 곱셈 연산의 수는 N*M*K 이다."

그리고 이 글을 보고 계실 하이에나 친구들은 이미 잘 알고 계시겠지만, 두 행렬의 곱셈이 성립하기 위해선, **(앞 행렬의 열 수 == 뒤 행렬의 행 수)** 를 만족해야 합니다.

### 주어지는 입력 행렬의 특징
문제에서는 입력 행렬에 대해 다음과 같은 조건을 부여합니다.

"행렬의 순서만 그대로라면, 곱셈 순서를 어떻게 정하더라도 결과가 성립하는 입력만 주어진다."

즉, 이웃한 행렬 A, B 간 곱셈이 성립하고, A*B*C 가 존재할 때 A*(B*C) 를 성립하는 행렬만 주어진다는 것입니다.

앞서 함께 살펴본 '행렬 곱셈 규칙'을 다시 한 번 고민해보면 다음과 같은 결론을 이끌어낼 수 있습니다.

입력으로 주어지는 전체 N 개의 행렬 중 p번째 행렬을 P, q번째 행렬을 Q라고 해보겠습니다. (1 <= p <= q <= N)

그렇다면 P와 Q 사이에 임의 갯수의 행렬이 주어져있을 것입니다.

`P .... L ..... Q`

위의 조건을 고려하면, P부터 Q까지 모든 행렬을 어떤 순서로 계산하더라도 결과 행렬은 다음의 조건을 만족함을 도출할 수 있습니다.

> **행렬 R = P부터 Q까지 존재하는 모든 행렬을 계산한 결과 라고 할 때,**
> 
> **R의 행 수 = P의 행 수**  
> **R의 열 수 = Q의 열 수**

---

## II. 알고리즘 설계 : 정당성 분석

이제 본격적으로 어떻게 이 문제를 해결할 수 있을지 살펴보겠습니다.

먼저 핵심 아이디어를 정리해보면 다음과 같습니다.

> "i번째부터 j번째까지의 행렬을 모두 곱하는 최소 연산 수를 구하기 위해서는, 이 구간을 두 부분으로 나누어 각각의 최소 연산 수를 활용할 수 있다."

이를 조금 더 자세히 설명해보겠습니다.

i번째부터 j번째까지 행렬이 있을 때, k번째를 기준으로 두 그룹으로 나눌 수 있습니다.
- **왼쪽 그룹**: i번째 ~ k번째 행렬
- **오른쪽 그룹**: (k+1)번째 ~ j번째 행렬

즉, 전체 구간 (i, j)의 최적해를 계산하기 위해 모든 부분 구간 조합의 최적해를 살펴보고 비교하는 것입니다.

이때 필요한 총 연산 수는 다음 세 가지의 합입니다:
- **1) 왼쪽 그룹을 계산하는데 필요한 최소 연산 수**: dp[i][k]
- **2) 오른쪽 그룹을 계산하는데 필요한 최소 연산 수**: dp[k + 1][j]
- **3) 두 결과 행렬을 곱하는데 필요한 연산 수**: multiply(matrix(i, k), matrix(k+1, j))

앞서 I에서 도출한 결론을 떠올려보면,
- 왼쪽 그룹의 결과 행렬: (i번 행렬의 행 수) × (k번 행렬의 열 수)
- 오른쪽 그룹의 결과 행렬: ((k+1)번 행렬의 행 수) × (j번 행렬의 열 수)

따라서 두 결과를 곱하는 연산 수는 **(i번 행렬의 행 수) × (k번 행렬의 열 수) × (j번 행렬의 열 수)** 가 됩니다.

그리고 우리는 k를 i부터 j-1까지 모두 시도해보면서, 그 중 최소값을 선택하면 i~j 구간의 최소 연산 수를 구할 수 있습니다!

이것이 바로 **'구간 DP'의 핵심 아이디어**입니다. 큰 구간의 문제를 작은 구간의 문제로 쪼개서 해결하는 것입니다.

---

## III. 점화식 설계

이제 앞서 분석한 내용을 바탕으로 점화식을 설계해보겠습니다.

다들 아시겠지만 일반적으로 DP 는 두 가지 방식으로 설계할 수 있습니다. 재귀 방식의 **Top-down**, 그리고 반복문을 활용하여 가장 작은 부분문제부터 해결해 끝에 전체 문제 해답에 도달하는 **Bottom-up** 방식입니다.

이 문제의 경우, 탐색 공간의 크기와 시간/공간 제약을 고려하여 **Bottom-up 방식**으로 설계하였습니다.

따라서 다음과 같은 풀이를 설계하였습니다.

1. 구간의 길이를 1부터 N까지 늘려가며 (`구간 길이 l in range(1, N)`),
2. N 개의 행렬 각각을 시작점으로 하는 구간 (s, s + l - 1)에 대해, (`시작 행렬 번호 s in range(0, N - l)`)
3. dp[s][s + l - 1] 을 구한다.

각 단계의 입력 크기가 N에 수렴하므로, **O(N³) 시간 복잡도**를 갖습니다.

일반적으로라면 냅다 갖다버려야하는 시간복잡도이나,
- 입력의 크기인 N이 최대 500이라는 점,
- 따라서 N³ 이 1억을 크게 넘지 않는 다는 점,
- 위의 풀이를 구성하는 대다수의 연산이 덧셈 또는 대입, 배열 조회와 같이 비용이 저렴한 연산이라는 점.

위의 세 가지를 고려하여 현 문제의 시간/공간 제약에 부합하는 시간복잡도라고 생각하였습니다.

### DP 테이블 정의
**dp[i][j] = i번째 행렬부터 j번째 행렬까지 모두 곱할 때 필요한 최소 곱셈 연산 수**

### Base Case: i == j
i == j 일 때, 즉 행렬이 하나만 있을 때는 곱셈 연산이 필요하지 않습니다.

**dp[i][i] = 0**

### 점화식
i < j 일 때, k를 i부터 j-1까지 움직이며 최소값을 찾습니다.

**dp[i][j] = min(dp[i][k] + dp[k+1][j] + (두 구간행렬곱의 결과인 행렬 두 개 P, Q의 곱셈에 필요한 연산 수))**  
(for k in range(i, j - 1))

---

## 코드 구현
```java
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.util.StringTokenizer;

public class Main {
    
    static int[][] dp; // dp[i][j] : i번째 행렬부터 j번째 행렬까지 곱셈할 때 필요한 최소 곱셉 연산 수
    static int N; // 행렬 수
    static int[][] matrices; // 행렬들
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        N = Integer.parseInt(br.readLine());
        dp = new int[N][N];
        matrices = new int[N][2];
        
        // 1. 행렬 입력 받기
        for(int n = 0; n < N; n++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            int r = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());
            
            matrices[n][0] = r;
            matrices[n][1] = c;
        }
        
        // 2. solution 실행
        // (1, N) 범위 내에 존재하는 임의의 l 길이의,
        for(int l = 1; l < N + 1; l++){
            // (0, N-l) 범위 내에 존재하는 s를 시작점으로 하는 구간에 대해, 해당 구간의 행렬을 곱하는 최소 곱셈횟수 찾기.
            for(int s = 0; s < N - l + 1; s++){
                calculateDP(s, s + l - 1);
            }
        }
        
        // 3. 출력
        System.out.print(dp[0][N-1]);
    }
    
    // dp[i][j] 계산
    public static void calculateDP(int i, int j){
        if(i == j){
            dp[i][j] = 0;
        }
        else if(i == j - 1){
            dp[i][j] = multiplyMatrices(
                matrices[i][0], matrices[i][1], matrices[j][0], matrices[j][1]
            );
        }
        else {
            int minByFarForIAndJ = Integer.MAX_VALUE;
            for(int k = i; k < j; k++){
                int currentMin = dp[i][k] + dp[k + 1][j] + 
                    multiplyMatrices(matrices[i][0], matrices[k][1], matrices[k+1][0], matrices[j][1]);
                
                minByFarForIAndJ = Math.min(minByFarForIAndJ, currentMin);
            }
            dp[i][j] = minByFarForIAndJ;
        }
    }
    
    // 두 행렬 곱셈에 필요한 곱셈 연산 수 계산
    public static int multiplyMatrices(int r1, int c1, int r2, int c2){
        return r1 * c1 * c2;
    }
}
