# 1. 알고리즘 수업 1
```python
import sys

input = sys.stdin.readline
sys.setrecursionlimit(1000000)

N, M, R = map(int, input().split())

adjacency_by_node = [[] for _ in range(N + 1)]
for _ in range(M):
    a, b = map(int, input().split())
    adjacency_by_node[a].append(b)
    adjacency_by_node[b].append(a)

for node in range(1, N + 1):
    if adjacency_by_node[node]:
        adjacency_by_node[node].sort()

visit_order = [0] * (N + 1)
next_order = 0

def dfs(current):
    global next_order
    next_order += 1
    visit_order[current] = next_order
    for neighbor in adjacency_by_node[current]:
        if visit_order[neighbor] == 0:
            dfs(neighbor)

dfs(R)
sys.stdout.write("\n".join(str(visit_order[i]) for i in range(1, N + 1)))

```

정점의 수 N, 간선의 수 M, 시작 정점 R, 간선 정보

가중치 없는 무방향 그래프가 주어졌을 때, 시작 정점 R에서 깊이 우선 탐색을 수행

이때 방문 순서를 차례대로 출력하고, 방문하지 못한다면 0

예시 1

```python
5 5 1
1 4
1 2
2 3
2 4
3 4
```

1 → 2 (오름차순 순을 방문해서 4는 방문 하지 않음)

2 → 3 (’’)

3 → 4

4 → 1,2,3  

5 → x

다른  dfs문제들과 다르게 오름차순 방문이라는 조건이 붙었기 때문에 order라는 변수를 두어 카운터를 증가시키며 기록하고, 오름차순 순으로 방묺하기 위해 정렬을 수행한다.

- 시간 복잡도는 dfs 에서 벗어나지 않았기에 O(N + M)
- m이 최대 200000 라서 input()을 쓸 경우 시간 초과 발생
    - 파이썬에서 input()은 내부적으로 sys.stdin.readline()을 감싸며 추가 처리를 해서 꽤 느리다
    - 파이썬 재귀 깊이한도는 1000까지 인데 반해 m이 그보다 커서 재귀 한도를 올려줘야함
    - 재귀 대신 반복 dfs 쓰는 방법도 있을 듯



# 2. 토마토 

```python
from collections import deque
import sys
input = sys.stdin.readline
dx = [1, -1, 0, 0, 0, 0]
dy = [0, 0, -1, 1, 0, 0]
dz = [0, 0, 0, 0, -1, 1]
def bfs():
    while q:
        a, b, c = q.popleft()
        visit[c][a][b] = 1
        for i in range(6):
            x = a + dx[i]
            y = b + dy[i]
            z = c + dz[i]
            if 0 <= x < n and 0 <= y < m and 0 <= z < h and s[z][x][y] == 0 and visit[z][x][y] == 0:
                q.append([x, y, z])
                s[z][x][y] = s[c][a][b] + 1
                visit[z][x][y] = 1
m, n, h = map(int, input().split())
s = [[] for i in range(h)]
visit = [[[0 for i in range(m)] for i in range(n)] for i in range(h)]
q = deque()
isTrue = False
st = False
for i in range(h):
    for j in range(n):
        s[i].append(list(map(int, input().split())))
for z in range(h):
    for x in range(n):
        for y in range(m):
            if s[z][x][y] == 1:
                q.append([x, y, z])
bfs()
max_num = 0
for z in range(h):
    for x in range(n):
        for y in range(m):
            if s[z][x][y] == 0:
                isTrue = True
            max_num = max(max_num, s[z][x][y])
if isTrue == True:
    print(-1)
else:
    print(max_num - 1)
```

- 1 : 익은 토마토
- 0 : 안익은 토마토
- -1 : 없는 토마토

하루가 지나면 상하좌우앞뒤 6방향이 1(익은 토마토)이 된다. 이떄 모든 토마토가 익을때까지 걸리는 최소 일수

예외. 전부 익어있을 경우 0, 불가능 할경우 -1

**풀이 방법**

- 1을 큐에 넣어놓고 순차로 방문한다
    - 방문 시 6방향 중 값이 0인 것만 방문, 그 칸의 값을 부모 값 +1 로 저장 == 그칸 부모가 익은 날 + 1

**풀이 과정**

- m, n, h = 가로, 세로, 높이
- 방향 벡터 dx, dy, dz
- 처음부터 값이 1인 좌표를 큐에 넣고 방문
- 경계 안이고, 아직 안 익은 칸(s[z][x][y] == 0)이고, 방문 안 했으면
    - 큐에 넣고
    - s[z][x][y] = s[c][a][b] + 1
- 모든 칸을 돌아도 0이 남아 있으면 -1
- s에 저장된 값의 최댓 값에서 -1 (시작부터 익은 토마토가 1부터 카운팅 되었기에 -1)

시간 복잡도 o(hnm)

visit을 없애고, 큐에 넣는 시점에 s를 갱신하는 방식..?

# 3. 벽부수고 이동하기

**문제 설명**

- N * M의 격자 지도가 주어졌을 때 (1,1)에서 (N,M)까지 상하좌우로만 이동했을 때 최단 경로
- 벽을 하나 부숴서 지날 수 있음, 불가능할 경우 -1

부쉈을 때와 부수지 않았을 때를 비교해야 최단 경로를 구할 수 있기때문에 방문 배열을 2중으로 구성한다.

최단 거리 구하는 문제이므로 bfs를 사용하면 되고, bfs에서 처음 도달에 성공한 값이 최단 거리가 된다

```python
from collections import deque
import sys

input = sys.stdin.readline

n, m = map(int, input().split())
grid = [input().strip() for _ in range(n)]

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

visited_row = [[[0] * 2 for _ in range(m)] for _ in range(n)]

q = deque()
q.append((0, 0, 0))
visited_row[0][0][0] = 1

while q:
    x, y, wall_break_used = q.popleft()

    if x == n - 1 and y == m - 1:
        print(visited_row[x][y][wall_break_used])
        sys.exit(0)

    cur_steps = visited_row[x][y][wall_break_used]

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if not (0 <= nx < n and 0 <= ny < m):
            continue

        cell = grid[nx][ny]

        if cell == '0' and visited_row[nx][ny][wall_break_used] == 0:
            visited_row[nx][ny][wall_break_used] = cur_steps + 1
            q.append((nx, ny, wall_break_used))

        elif cell == '1' and wall_break_used == 0 and visited_row[nx][ny][1] == 0:
            visited_row[nx][ny][1] = cur_steps + 1
            q.append((nx, ny, 1))

print(-1)

```
