## 1. 최단 경로
https://www.acmicpc.net/problem/1753

**문제 설명**

방향 그래프가 주어지고, 주어진 시작점에서 다른 모든 정점까지 갈 수 있는 최단 거리를 구하는 문제입니다
(1 ≤ V ≤ 20,000, 1 ≤ E ≤ 300,000)


**풀이**

그냥 대놓고 다익스트라 문제네요! V랑 E의 최대 수가 커서 점화식은 시간초과 날 것 같아서 우선 순위 큐로 풀어보았습니다
마찬가지로 V의 개수가 커서 인접 행렬로 그래프를 사용하면 메모리초과가 발생할 것이라 인접 리스트(풀이 내 edge_list)로 구성하면 해결할 수 있습니다
- (방문 횟수, 정점)를 우선순위 큐에 저장
- 방문 횟수가 가장 적은 정점부터 탐색
- 이 과정에서 더 적은 방문횟수로 저장된 데이터가 존재하면 continue로 해당 과정을 건너뜁니다!
- 마지막으로 모든 V에 대해 가장 적은 방문 횟수인 min_cost를 확인하고, 이때 min_cost가 INF면 갈 수 없는 정점으로 INF 아니면 최소 비용을 출력합니다


```python3
from sys import stdin, stdout
import heapq

readedge_list = stdin.readline

v_cnt, e_cnt = map(int, read().split())
start_v = int(read())

edge_list = [[] for _ in range(v_cnt + 1)]
for _ in range(e_cnt):
    u, v, w = map(int, read().split())
    edge_list[u].append((v, w))

INF = 10**18
min_cost = [INF] * (v_cnt + 1)
min_cost[start_v] = 0

pq = [(0, start_v)]
while pq:
    cost_so_far, node = heapq.heappop(pq)
    if cost_so_far > min_cost[node]:
        continue
    for nxt_node, weight in edge_list[node]:
        nxt_cost = cost_so_far + weight
        if nxt_cost < min_cost[nxt_node]:
            min_cost[nxt_node] = nxt_cost
            heapq.heappush(pq, (nxt_cost, nxt_node))

out_lines = []
for i in range(1, v_cnt + 1):
    out_lines.append("INF" if min_cost[i] == INF else str(min_cost[i]))
stdout.write("\n".join(out_lines))
```
우선순위 큐 말고도 벨만포드나 bfs 써서 풀 수 있을 것 같은데 풀어보신분 있다면 후기 들려주십쇼..

## 2. 최소 비용 구하기
https://www.acmicpc.net/problem/1916

**문제 설명**

도시 N, 버스 M개가 있을 때 도시 A에서 B까지 가는 최소 비용을 구하는 문제입니다 
방향 그래프를 활용해서 최단 비용을 찾는 문제네요 요것도 위에 문제랑 똑같이 힙을 활용해서 다익스트라로 해결 가능합니다
괜히 다익스트라 + 힙 쓰기 싫어서 bfs로 풀어봤는데 시간 초과만 나고 끝났습니다..ㅎ

**풀이 과정**

```python3
from sys import stdin, stdout
import heapq

read = stdin.readline

city_cnt = int(read())
bus_cnt = int(read())

edge_list = [[] for _ in range(city_cnt + 1)]
for _ in range(bus_cnt):
    u, v, w = map(int, read().split())
    edge_list[u].append((v, w))

start_city, end_city = map(int, read().split())

INF = 10**18
min_cost = [INF] * (city_cnt + 1)
min_cost[start_city] = 0

results = [(0, start_city)]

while results:
    cost_so_far, node = heapq.heappop(results)
    if cost_so_far > min_cost[node]:
        continue

    for nxt_city, fee in edge_list[node]:
        nxt_cost = cost_so_far + fee
        if nxt_cost < min_cost[nxt_city]:
            min_cost[nxt_city] = nxt_cost
            heapq.heappush(results, (nxt_cost, nxt_city))

stdout.write(str(min_cost[end_city]) + "\n")

```
